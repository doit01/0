以下为你介绍一些常见的JVM优化面试题及参考答案：

### 基础概念类
1. **什么是JVM调优？**
JVM调优是指对Java虚拟机进行优化，以提高Java应用程序的性能和吞吐量。通过对JVM参数的调整、内存管理以及垃圾收集等方面的优化，可以使Java应用程序更加高效地运行。
2. **JVM内存模型包含哪些部分？**
JVM内存模型主要包括程序计数器、堆、本地方法栈、Java栈和方法区（JDK 1.7之后更改为元空间，并直接使用系统内存）。其中，堆用于存放对象实例，是垃圾回收的主要区域；方法区存储已被虚拟机加载的类信息、常量、静态变量等。
3. **什么是双亲委派机制及其作用？**
双亲委派机制指的是当一个类需要被加载时，它的加载请求会被委托给它的父类加载器，父类加载器会先尝试加载这个类，如果加载成功就返回，如果加载失败则会将加载请求再委托给它的父类加载器，直到最顶层的启动类加载器（Bootstrap ClassLoader）。只有当最顶层的启动类加载器也无法加载时，才会由当前类加载器自己来进行加载。使用该机制可以确保类的加载是由低层次的加载器向高层次的加载器进行委托，从而保证了类的唯一性和安全性，避免出现Java本地类被底层加载器加载的情况。

### 性能调优类
1. **什么情况下需要进行JVM调优？**
    - Heap内存（老年代）持续上涨达到设置的最大内存值。
    - Full GC次数频繁。
    - GC停顿（Stop World）时间过长（超过1秒，具体值按应用场景而定）。
    - 应用出现OutOfMemory等内存异常。
    - 应用出现OutOfDirectMemoryError等内存异常。
    - 应用中有使用本地缓存且占用大量内存空间。
    - 系统吞吐量与响应性能不高或下降。
    - 应用的CPU占用过高不下或内存占用过高不下。
2. **JVM调优有哪些常用策略？**
    - **调整JVM参数**：如设置初始堆大小（-Xms）、最大堆大小（-Xmx）、年轻代与老年代的比例（-XX:NewRatio）等。例如，一般将初始堆大小和最大堆大小设置为相同值，防止内存震荡和抖动。
    - **选择合适的垃圾回收器**：JVM提供了多种垃圾回收器，如Serial收集器、Parallel收集器、CMS收集器、G1收集器等。对于响应性要求高的应用程序，可以使用Serial收集器或CMS收集器；对于处理大量对象的批处理应用程序，可以使用Parallel收集器。
    - **优化类加载器性能**：避免创建过多的类加载器对象；将常用的类放在启动类加载器或扩展类加载器中，以避免重复加载；避免使用动态类加载。
    - **代码优化**：避免创建过多的临时对象；避免在GC期间进行I/O操作等。
3. **如何优化JVM的新生代和老年代大小？**
    - **新生代**：对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次Minor GC。而那些无需回收的存活对象，将会进到Survivor的From区（From区内存不足时，直接进入Old区）。可以根据对象存活率和分配速率调整新生代大小，通常使用 -Xmn 参数设置新生代大小，也可通过 -XX:NewSize/-XX:MaxNewSize、-XX:NewRatio 来设置。
    - **老年代**：长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，当对象经过一定次数的Minor GC后，年龄达到阈值（默认15次），对象进入老年区。可以根据应用的长期存活对象数量调整老年代大小，一般使用 -Xmx 参数设置老年代的最大大小。

### 工具使用类
1. **JVM常用性能调优工具有哪些？**
    - **JConsole**：JDK自带的Java监控和管理平台，主要用于JVM内存和线程的监控，可以监控Java应用程序的CPU使用率、内存使用情况、线程数以及垃圾收集的频率和时间等。
    - **JVisualVM**：JDK中自带的可视化工具，可以查看本地应用以及远程服务器上应用程序的相关数据，还能捕获相关数据保存在本地以供后期分析，可进行性能分析以找出CPU和内存使用的瓶颈。
    - **MAT（Memory Analyzer Tool）**：一个基于Eclipse的内存分析工具，可用于分析堆转储文件，找出内存泄漏等问题。
2. **如何使用JVM工具进行性能问题检测？**
    - **jps**：JDK自带，用于列出系统中运行的所有Java进程。
    - **jinfo**：可列出端口号对应JVM的详细信息，包括JVM版本、操作系统和编码信息、虚拟机参数等。
    - **jstat**：用于打印JVM的内存使用情况，如使用 jstat -gc port 可查看指定端口号对应的JVM的垃圾回收统计信息。
    - **jstack**：用于追踪Java线程的资源使用情况，包括线程的名字、状态、调用的方法堆栈等，常用于查找具体的哪些Java线程在占用内存、CPU甚至出现死锁。
    - **jmap**：如使用 jmap -histo pid 可查看指定进程的JVM中加载了哪些类以及创建了多少对象；使用 jmap -dump:format=b,file=xxx.hprof pid 可将JVM转储为一个文件，方便后续分析。

### 故障处理类
1. **什么情况下会抛出OutOfMemoryError（OOM）？**
当JVM 98%的时间都花费在内存回收，并且每次回收的内存小于2%时，会触发OutOfMemoryException。此外，内存不足、内存泄露、加载过多类等情况也可能导致OOM。
2. **系统OOM之前都有哪些现象？**
每次垃圾回收的时间越来越长，Full GC的时间也变长；Full GC的次数越来越多；老年代的内存越来越大，并且每次Full GC后，老年代只有少量的内存被释放掉。
3. **如何进行堆Dump文件分析？**
可以通过指定启动参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/app/data/ ，在发生OOM时自动生成堆转储文件。然后使用工具如MAT（Memory Analyzer Tool）来分析该文件，找出内存泄漏的根源。


springboot starter 自定义
1 create base project module
2 add meta data{
create meta-inf directory in src/main/resources/
add spring.factories file in which delares a auto configration class

spring.factories 
like org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.starter.MyAutoConfiguration

}
3 write a autoconfration class using @ConditionalOnClass
@ConditionalOnMissingBean, @ConditionalOnProperty to set the condition
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnClass({ MyService.class })
@EnableConfigurationProperties(MyProperties.class)
public class MyAutoConfiguration {
    @Autowired
    private MyProperties myProperties;

    @Bean
    @ConditionalOnMissingBean(MyService.class)
    public MyService myService() {
        return new MyServiceImpl(myProperties.getMessage());
    }
}

4 write the configration property class by using @ConfigurationProperties
it can bind the propties in configration yml file to the bean.

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "my.service")
public class MyProperties {
    private String message;

    // getters and setters...
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}

5 deploy it the nexus or maven central
服务发现与配置管理面试题详解
一、‌服务发现核心机制‌

核心流程与机制‌
注册流程‌：服务提供者启动时向注册中心（如 Nacos、Eureka）发送注册请求，携带服务名、IP、端口等元数据。
健康检查‌：通过心跳机制（默认间隔 30s，超时 90s）监控服务状态，异常实例自动剔除。
服务拉取‌：消费者从注册中心拉取服务列表并缓存本地，后续调用基于本地缓存（减少注册中心压力）。

常见面试题‌
Q1：服务发现的核心作用？‌
答：解耦服务提供者与消费者，实现动态路由与负载均衡，避免硬编码地址。
Q2：Nacos 与 Eureka 的差异？‌
协议支持‌：Nacos 支持 HTTP/DNS/gRPC，Eureka 仅 HTTP。
数据一致性‌：Nacos 支持 AP（默认）和 CP 模式，Eureka 仅 AP。
Q3：服务剔除的触发条件？‌
答：未按时发送心跳、主动下线请求或注册中心主动健康检查失败。

二、‌配置管理核心机制‌
核心流程与机制‌
配置存储‌：配置中心（如 Nacos、Spring Cloud Config）集中管理配置项，支持多环境（dev/test/prod）隔离。
动态更新‌：客户端监听配置变更，通过长轮询或事件推送实时生效（无需重启服务）。
版本控制‌：支持历史版本回滚与配置差异对比，降低配置错误风险。

常见面试题‌
Q1：动态配置如何实现不重启生效？‌
答：客户端通过 @RefreshScope 注解（Spring Cloud）或监听器（Nacos）重新加载配置，结合本地缓存减少性能开销。
Q2：配置中心如何保证数据一致性？‌
Nacos‌：基于 Raft 协议实现集群数据同步（CP 模式）或异步复制（AP 模式）。
Spring Cloud Config‌：依赖 Git 仓库的版本控制能力，强一致性需结合消息总线（如 Spring Cloud Bus）。
Q3：多环境配置管理方案？‌
答：通过命名空间（Nacos）或 Profile（Spring Cloud）隔离不同环境配置，结合 Git 分支管理实现版本控制。
三、‌高频进阶问题‌

服务发现与负载均衡的协作‌

注册中心提供实例列表，客户端负载均衡器（如 Ribbon）基于策略（轮询、权重、随机）选择目标实例。

配置中心高可用设计‌
集群部署‌：Nacos 通过多节点集群 + 数据分片提升可用性。
容灾备份‌：定期快照备份配置数据，支持故障时快速恢复。

服务治理的扩展能力‌

动态路由‌：结合 API 网关（如 Spring Cloud Gateway）实现基于服务名的智能路由。
熔断降级‌：通过 Sentinel 或 Hystrix 监控服务健康状态，异常时触发熔断策略。
总结
模块‌	‌核心考点‌	‌关联技术栈‌
服务发现‌	注册/心跳/剔除机制、AP与CP模式对比、负载均衡协作	Nacos、Eureka、Consul
配置管理‌	动态更新原理、多环境隔离、数据一致性方案	Nacos、Spring Cloud Config



​灰度发布如何实现？
​步骤：
在 Gateway 中根据请求头（如 version）路由到不同服务版本

​配置中心：Spring Cloud Config + Bus 实现动态刷新

分布式追踪
11. ​Sleuth 如何生成 Trace ID？
​流程：
请求进入网关时生成唯一 Trace ID。
通过 HTTP Header 传递至下游服务。
Zipkin 收集并展示链路调用图。

过滤器类型：
​GatewayFilter：单个路由过滤器（如 AddRequestHeader）。
​GlobalFilter：全局过滤器（如鉴权、限流）。

​Feign 如何实现声明式服务调用？
​原理：通过动态代理生成接口实现类，结合 Ribbon 实现负载均衡。
