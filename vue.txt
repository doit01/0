html渲染过程：下面步骤：解析html，样式计算，布局，分块，绘制，分层，光栅化.
前端页面渲染核心流程详解

以下是浏览器渲染页面的核心步骤及其技术细节，按执行顺序梳理：

一、‌解析 HTML‌
DOM 树构建‌
渲染主线程将 HTML 字符串逐行解析为 ‌DOM 树‌（Document Object Model），每个 HTML 标签对应一个 DOM 节点。
预解析优化‌：预解析线程提前扫描 HTML 文档，优先下载外部 CSS 和 JS 文件，避免主线程阻塞。

阻塞与执行‌
解析过程中遇到 <script> 标签时，默认会暂停 HTML 解析以加载和执行 JS 代码（除非标记 async 或 defer）。
<link> 标签引入的 CSS 文件会被并行下载，但不会阻塞 HTML 解析（除非内联样式或未使用预加载）。
二、‌样式计算（Style Calculation）‌
CSSOM 构建‌
解析 CSS 文件（包括浏览器默认样式、内联样式、外部样式）生成 ‌CSSOM 树‌（CSS Object Model）。
样式属性通过层叠（优先级计算）和继承规则确定最终值。
Computed Style 生成‌
将 DOM 树与 CSSOM 树结合，为每个 DOM 节点计算最终样式（如颜色、字体大小等），生成带样式的 DOM 树。
三、‌布局（Layout）‌
布局树（Render Tree）构建‌
基于带样式的 DOM 树生成 ‌布局树‌，仅包含可见元素（如隐藏元素、<head> 等被排除）。
节点尺寸和位置通过盒模型（width、margin 等）精确计算。

布局计算规则‌
块级元素按垂直方向排列，行内元素按水平排列，遵循流式布局规则。
四、‌分层（Layering）‌
分层策略‌
将页面划分为多个独立层级（如滚动容器、动画元素、定位元素等），提升渲染效率。
分层决策依据：z-index、opacity、transform 等属性。
优化意义‌
仅更新受影响层级，避免全页面重绘（如滚动时仅更新特定层）。

五、‌绘制（Paint）‌
绘制指令生成‌
主线程为每个图层生成 ‌绘制指令集‌（如绘制矩形、文本等操作的详细描述）。
示例指令：绘制红色矩形（位置、尺寸、颜色等参数）。
提交至合成线程‌
主线程将绘制指令提交给 ‌合成线程‌，后续渲染流程由合成线程接管。

六、‌分块（Tiling）与光栅化（Rasterization）‌
分块处理‌
合成线程将每个图层划分为 ‌图块‌（Tile，通常为 256x256 或 512x512 像素），优先处理靠近视口的图块。
分块支持“懒加载”式渲染，提升长页面滚动性能。

光栅化执行‌
GPU 加速‌：光栅化线程（通常由 GPU 执行）将矢量绘制指令转换为 ‌像素数据‌，存储为位图。
复杂效果（如阴影、渐变）在此阶段完成像素级计算。
七、‌合成与呈现（Composite & Display）‌
合成操作‌
合成线程将光栅化后的图块按层级顺序组合成完整页面图像。
提交至显示系统‌
最终图像通过 ‌GPU 进程‌ 提交给操作系统或显示器驱动，完成屏幕刷新。
关键优化点
减少重排（Reflow）与重绘（Repaint）‌
布局和绘制阶段开销大，应避免频繁修改样式或 DOM 结构。
利用分层与合成‌
使用 transform 或 opacity 实现动画，可跳过布局和绘制阶段，直接由合成线程处理。
分块与光栅化并行‌
多线程协作（主线程、合成线程、光栅化线程）提升渲染效率。


CSS核心两大块：
css 属性值计算过程包括（层叠，继承）
视觉格式化模型（盒模型，包含块，流式布局，浮动布局，BFC）


BFC
1、概念
https://blog.csdn.net/Cui_7788/article/details/103135878?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-103135878-blog-121292449.235^v43^pc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=2
BFC：块级格式化上下文，是页面中的一块渲染区域，有一套自己的渲染规则，决定子元素如何定位，以及和其他元素的关系和相互作用
2、作用

作用：可以将BFC理解成一个箱子，不会影响箱子外部，解决传统布局带来的问题

传统布局问题：
相邻块元素的垂直外边距合并：两个盒子设置BFC
嵌套块元素的垂直外边距塌陷：父级盒子设置BFC，父元素position
浮动流造成父级元素高度坍塌：父级盒子设置BFC
浮动元素覆盖：非浮动元素设置BFC
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
                        
原文链接：https://blog.csdn.net/weixin_44706267/article/details/121292449


CSS 的核心两项
一、‌盒模型（Box Model）‌

盒模型定义了元素的‌尺寸计算规则‌，包含四个层级结构：content（内容区）、padding（内边距）、border（边框）、margin（外边距）。

块盒（Block）‌：通过 width 和 height 设置内容区尺寸，完整包含 padding 和 border，垂直方向 margin 会叠加。
行盒（Inline）‌：宽高由内容决定，无法直接设置 width 和 height，垂直方向的 padding 和 border 不占据布局空间（仅水平方向生效）。
二、‌显示模式（Display Mode）‌

通过 display 属性控制元素的‌布局行为‌，决定元素在文档流中的排列方式与交互规则：

块级显示（Block）‌：独占一行，可设置宽高，默认宽度为父容器 100%。
行内显示（Inline）‌：水平排列，宽高由内容撑开，无法设置垂直方向 margin 和 padding。
行内块（Inline-Block）‌：兼具块级可设宽高与行内水平排列的特性，如 <img>、<input> 等元素默认此模式。
核心作用总结
特性‌	‌盒模型‌	‌显示模式‌
布局控制‌	决定元素占据的实际空间（包含内容、间距、边框）	决定元素排列方式（独占行或水平排列）及尺寸控制能力
设计意义‌	统一元素尺寸计算规则，避免布局错位	通过 display 属性灵活切换元素的渲染逻辑，适配不同场景需求
典型应用
盒模型‌：精确控制元素间距（如导航栏按钮间距）或实现等高布局（通过 padding 和 margin 调整）。
显示模式‌：用 inline-block 实现水平菜单项，或通过 block 构建页面容器结构。

shallowRef是Vue3中的一个响应式API，用于创建浅层响应式对象。与ref不同，shallowRef仅对.value属性进行响应式跟踪，不会递归处理嵌套对象。这意味着修改嵌套属性时不会触发视图更新
性能敏感场景‌：优先用于深层嵌套对象、大数据集合以减少递归追踪开销‌14。
‌数据不可变或外部集成‌：适用于仅需监听整体引用变化的场景‌27。
‌精准更新控制‌：需手动管理更新逻辑时，通过替换 .value 触发响应‌

Vue 2：选项式 API（data、methods 分离）‌2。
Vue 3：组合式 API（setup 函数整合逻辑，支持逻辑复用


    Vue 2 无法检测对象属性新增/删除（需用 Vue.set/Vue.delete）和数组部分方法（如 splice 需覆盖）‌13。
    Vue 3 的 Proxy 已解决上述问题‌2。
生命周期调整‌
    Vue 3 移除 beforeCreate 和 created，统一由 setup 替代‌23。
    新增 onBeforeUnmount 和 onUnmounted 替代 beforeDestroy 和 destroyed‌23。

Vue 3 支持 ‌Tree Shaking‌（按需引入模块），打包体积更小‌

组件通信方式‌
    ‌父子‌：props + $emit‌14。
    ‌兄弟/跨级‌：事件总线（Event Bus）、provide/inject、Vuex/Pinia‌45。
    ‌Vue 3 新增‌：defineProps、defineEmits 编译器宏‌2。


行盒（Inline）与块盒（Block）的核心区别
一、‌功能目标与显示方式‌
特性‌	‌行盒（Inline）‌	‌块盒（Block）‌
排列方式‌	水平排列，与其他行盒共享同一行，宽度由内容决定	垂直排列，独占一行，宽度默认占满父容器
内容范围‌	仅容纳文本、行内元素或行块盒，不可嵌套块盒	可包含行盒、块盒及其他复杂内容
二、‌尺寸控制与盒模型‌

行盒‌

宽高‌：由内容决定，无法直接设置 width 和 height，调整内容尺寸（如字体大小）可间接改变布局。
盒模型‌：垂直方向的 padding 和 border 不占据布局空间（仅背景覆盖），水平方向有效。
示例‌：
css
Copy Code
span {  
  padding: 10px; /* 水平方向生效，垂直方向不改变布局高度 */  
  border: 1px solid red;  
}  


块盒‌

宽高‌：可自由设置 width 和 height，默认宽度占满父容器。
盒模型‌：包含完整的 content、padding、border、margin，垂直和水平方向均影响布局。
示例‌：
css
Copy Code
div {  
  width: 300px;  
  padding: 20px; /* 所有方向均占据空间 */  
  margin: 10px auto; /* 水平居中 */  
}  

三、‌典型应用场景‌

行盒适用场景‌

文本段落中的部分样式（如 <span> 高亮关键词）。
图标、按钮等需水平排列的小元素。

块盒适用场景‌

布局容器（如 <div> 包裹页面区块）。
导航栏、列表项等需独占一行的组件。
四、‌扩展类型：行块盒（Inline-Block）‌
特性‌：结合行盒与块盒特点，可水平排列且支持设置宽高。
应用‌：
css
Copy Code
.inline-block {  
  display: inline-block;  
  width: 100px; /* 生效 */  
  vertical-align: middle; /* 控制垂直对齐 */  
}  

五、‌注意事项‌
空白折叠‌：行盒之间连续的空白符（如换行、空格）会被折叠为单个空格。
替换元素‌：<img>、<video> 等默认生成行盒，但宽高可设置（类似行块盒）。
旧术语问题‌：避免使用“块级元素”“行内元素”等表述，改用“块盒”“行盒”以匹配 CSS 规范。
总结

行盒与块盒是 CSS 布局的基础单位：

行盒‌：轻量级水平排列，适合文本修饰与简单交互。
块盒‌：结构化垂直布局，支撑复杂页面框架。
核心差异‌：排列方向、尺寸控制能力、盒模型对布局的影响范围。

