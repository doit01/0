如何看待Composition API 和 Options API?
Composition API和Options API是Vue.js中的两种组件编写方式。
Options API是Vue.js早期版本中使用的编写方式，通过定义一个options对象进行组件的配置，包括props、data、methods、computed、watch等选项。这种方式的优点在于结构清晰、易于理解，在小型项目中比较实用。
Composition API是Vue.js 3.x版本中新引入的一种组件编写方式，它以函数的形式组织我们的代码，允许我们将相关部分组合起来，提高了代码的可维护性和重用性。Composition API还提供了模块化、类型推断等功能，可以更好地实现面向对象编程的思想。
Composition API 更好的代码组织，更好的逻辑服用；可维护性，更好的类型推导，可拓展性更好；
两种API各有优缺点，使用哪种API取决于具体的项目需求。对于小型项目，Options API更为简单方便；对于大型项目，Composition API可以更好地组织代码。
总之，Vue.js的Composition API和Options API是为了满足不同开发者的需求而存在的，我们应该根据具体的场景选择使用哪种API，以达到更好的开发效果和代码质量。
简介总结：
Composition API 允许将逻辑更加集中和复用，通过 setup 函数组合多个逻辑块。
相比于 Options API 的分散代码，Composition API 更加模块化和可维护。
Vue3.0有什么更新

性能优化：Vue.js 3.0使用了Proxy替代Object.defineProperty实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。
Composition API：Composition API是一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。
TypeScript支持：Vue.js 3.0完全支持TypeScript，在编写Vue应用程序时可以更方便地利用TS的类型检查和自动补全功能。
新的自定义渲染API：Vue.js 3.0的自定义渲染API允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。
改进的Vue CLI：Vue.js 3.0使用了改进的Vue CLI，可以更加灵活地配置项目，同时支持Vue.js2.x项目升级到Vue.js 3.0。
移除一些API：Vue.js 3.0移除了一些不常用的API，如过渡相关API，部分修饰符等。

Proxy和Object.defineProperty的区别？
Proxy和Object.defineProperty都可以用来实现JavaScript对象的响应式，但是它们有一些区别：

实现方式：Proxy是ES6新增的一种特性，使用了一种代理机制来实现响应式。而Object.defineProperty是在ES5中引入的，使用了getter和setter方法来实现。
作用对象：Proxy可以代理整个对象，包括对象的所有属性、数组的所有元素以及类似数组对象的所有元素。而Object.defineProperty只能代理对象上定义的属性。
监听属性：Proxy可以监听到新增属性和删除属性的操作，而Object.defineProperty只能监听到已经定义的属性的变化。
性能：由于Proxy是ES6新增特性，其内部实现采用了更加高效的算法，相对于Object.defineProperty来说在性能方面有一定的优势。

综上所述，虽然Object.defineProperty在Vue.js 2.x中用来实现响应式，但是在Vue.js 3.0中已经采用了Proxy来替代，这是因为Proxy相对于Object.defineProperty拥有更优异的性能和更强大的能力。
Vue3升级了哪些重要功能？

新的API：Vue3使用createApp() 代替了 new Vue()方法来创建应用程序实例，并有新的组件注册和调用方法。


emits属性：：Vue 3的组件可以使用emits属性来声明事件。


生命周期


多个Fragment


移除.sync


异步组件的写法
根元素可以有不止一个元素了
新增 Teleport 传送门
destroyed 被改名为 unmounted 了（before 当然也改了）
ref 属性支持函数了



作者：啊买依拿
链接：https://juejin.cn/post/7462026065897963531
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

vue2和vue3 核心 diff 算法区别？
Vue 2.x使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。
Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能。
因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。
Vue3为什么比Vue2快？

响应式系统优化：Vue3引入了新的响应式系统，这个系统的设计让Vue3的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟DOM。这个新系统的一个重要改进就是提供了一种基于Proxy实现的响应式机制，这种机制为开发人员提供更加高效的API，也减少了一些运行时代码。
编译优化：Vue3的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。
更快的虚拟DOM：Vue3对虚拟DOM进行了优化，使用了跟React类似的Fiber算法，这样可以更加高效地更新DOM节点，提高性能。
Composition API：Vue3引入了Composition API，这种API通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种API不仅可以让Vue3应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。

Vue3如何实现响应式？
使用Proxy和Reflect API实现vue3响应式。
Reflect API则可以更加方便地实现对对象的监听和更新，可以用来访问、检查和修改对象的属性和方法，比如Reflect.get、Reflect.set、Reflect.has等。
Vue3会将响应式对象转换为一个Proxy对象，并利用Proxy对象的get和set拦截器来实现对属性的监听和更新。当访问响应式对象的属性时，get拦截器会被触发，此时会收集当前的依赖关系，并返回属性的值；当修改响应式对象的属性时，set拦截器会被触发，此时会触发更新操作，并通知相关的依赖进行更新。
优点：可监听属性的变化、新增与删除，监听数组的变化
vue3.0编译做了哪一些优化？
Vue 3.0作为Vue.js的一次重大升级，其编译器也进行了一些优化，主要包括以下几方面：

静态树提升： Vue 3.0 通过重写编译器，实现对静态节点（即不改变的节点）进行编译优化，使用HoistStatic功能将静态节点移动到 render 函数外部进行缓存，从而服务端渲染和提高前端渲染的性能。
Patch Flag：在Vue 3.0中，编译的生成vnode会根据节点patch的标记，只对需要重新渲染的数据进行响应式更新，不需要更新的数据不会重新渲染，从而大大提高了渲染性能。
静态属性提升：Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。免去了重复的创建操作，优化内存。 没做静态提升之前，未参与更新的元素也在render函数内部，会重复创建阶段。
做了静态提升后，未参与更新的元素，被放置在render 函数外，每次渲染的时候只要取出即可。同时该元素会被打上静态标记值为-1，特殊标志是负整数表示永远不会用于 Diff。
事件监听缓存：默认情况下绑定事件行为会被视为动态绑定（没开启事件监听器缓存），所以每次都会去追踪它的变化。开启事件侦听器缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用。
优化Render function：Vue 3.0的compile优化还包括：Render函数的换行和缩进、Render函数的条件折叠、Render函数的常量折叠等等。

总之，Vue 3.0通过多方面的编译优化，进一步提高了框架的性能和效率，使得Vue.js更加高效和易用。
watch和watchEffect的区别？
watch 和 watchEffect 都是监听器，watchEffect 是一个副作用函数。它们之间的区别有：


watch ：既要指明监视的数据源，也要指明监视的回调。


而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。


watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。


watch 运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。这一点可以通过 watch 的配置项 immediate 改变。


watchEffect有点像 computed ：

但 computed 注重的计算出来的值（回调函数的返回值）， 所以必须要写返回值。
而 watcheffect注重的是过程（回调函数的函数体），所以不用写返回值。

watch与 vue2.x中 watch 配置功能一致，但也有两个小坑

监视 reactive 定义的响应式数据时，oldValue 无法正确获取，强制开启了深度监视（deep配置失效）
监视 reactive 定义的响应式数据中某个属性时，deep配置有效。

请介绍Vue3中的Teleport组件。
Vue 3 中新增了teleport（瞬移）组件，可以将组件的 DOM 插到指定的组件层，而不是默认的父组件层，可以用于在应用中创建模态框、悬浮提示框、通知框等组件。
Teleport 组件可以传递两个属性：

to (必填)：指定组件需要挂载到的 DOM 节点的 ID，如果使用插槽的方式定义了目标容器也可以传入一个选择器字符串。
disabled (可选)：一个标志位指示此节点是否应该被瞬移到目标中，一般情况下，这个 props 建议设为一个响应式变量来控制 caption 是否展示。


例子如下： 
<template>
  <teleport to="#target">
    <div>这里是瞬移到target容器中的组件</div>
  </teleport>
  <div id="target"></div>
</template>


在上述示例中，<teleport> 组件往 #target 容器中，挂载了一个文本节点，效果等同于：

 

<template>
  <div id="target">
    <div>这里是瞬移到target容器中的组件</div>
  </div>
</template>

总之，Teleport 组件是 Vue3 中新增的一个非常有用的组件，可以方便地实现一些弹出框、提示框等组件的功能，提高了开发效率。
如何理解reactive、ref 、toRef 和 toRefs？

    ref： 函数可以接收原始数据类型与引用数据类型。- ref函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。
    reactive： 函数只能接收引用数据类型。
    toRef：针对一个响应式对象的属性创建一个ref，使得该属性具有响应式，两者之间保持引用关系。（入下所示，即让state中的age属性具有响应式）
    toRefs： 将一个响应式对象转为普通对象，对象的每一个属性都是对应的ref，两者保持引用关系

谈谈pinia?

Pinia 是 Vue 官方团队成员专门开发的一个全新状态管理库，并且 Vue 的官方状态管理库已经更改为了 Pinia。在 Vuex 官方仓库中也介绍说可以把 Pinia 当成是不同名称的 Vuex 5，这也意味不会再出 5 版本了。

优点

    更加轻量级，压缩后提交只有1.6kb。
    完整的 TS 的支持，Pinia 源码完全由 TS 编码完成。
    移除 mutations，只剩下 state 、 actions 、 getters 。
    没有了像 Vuex 那样的模块镶嵌结构，它只有 store 概念，并支持多个 store，且都是互相独立隔离的。当然，你也可以手动从一个模块中导入另一个模块，来实现模块的镶嵌结构。
    无需手动添加每个 store，它的模块默认情况下创建就自动注册。
    支持服务端渲染（SSR）。
    支持 Vue DevTools。
    更友好的代码分割机制，传送门。

    Pinia 配套有个插件 pinia-plugin-persist进行数据持久化，否则一刷新就会造成数据丢失

EventBus与mitt区别？

Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的 $on/$emit/$off 等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。

而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了， Vue3 推荐尽可能使用 props/emits、provide/inject、vuex 等其他方式来替代。

当然，如果 Vue3 内部的方式无法满足你，官方建议使用一些外部的辅助库，例如：mitt。

优点

    非常小，压缩后仅有 200 bytes。
    完整 TS 支持，源码由 TS 编码。
    跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。
    使用简单，仅有 on、emit、off 等少量实用API。

script setup 是干啥的？

scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：

    属性和方法无需返回，可以直接使用。
    引入组件的时候，会自动注册，无需通过 components 手动注册。
    使用 defineProps 接收父组件传递的值。
    useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
    默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。

v-if 和 v-for 的优先级哪个高？

在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。
setup中如何获得组件实例？

在 setup 函数中，你可以使用 getCurrentInstance() 方法来获取组件实例。getCurrentInstance() 方法返回一个对象，该对象包含了组件实例以及其他相关信息。

 

import { getCurrentInstance } from 'vue';

export default {
  setup() {
    const instance = getCurrentInstance();

    // ...

    return {
      instance
    };
  }
};

在上面的示例中，我们使用 getCurrentInstance() 方法获取当前组件实例。然后，我们可以将该实例存储在一个常量中，并在 setup 函数的返回值中返回。

需要注意的是，getCurrentInstance() 方法只能在 setup 函数中使用，而不能在组件的生命周期方法（如 created、mounted 等方法）中使用。另外，需要注意的是，如果在 setup 函数返回之前访问了 instance 对象，那么它可能是 undefined ，因此我们需要对其进行处理。
Vue3 中的 Suspense 是什么？如何使用它来处理异步组件？


Suspense 组件用于处理异步组件加载，提供了一个优雅的加载状态处理机制。

 

<template>
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>

<script>
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent(() =>
  import('./AsyncComponent.vue')
);

export default {
  components: {
    AsyncComponent
  }
}
</script>

Vue3 中如何创建和使用自定义指令

 

// 创建自定义指令
const app = createApp(App);
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
});

// 使用自定义指令
<template>
  <input v-focus />
</template>

 在 Vue3 中，如何使用 emits 选项来定义组件事件？它与 Vue2 的事件处理有何不同？

emits 选项用于显式定义组件可以发出的事件。相比于 Vue2 中的隐式事件，在 Vue3 中定义事件更加明确。

 

export default {
  emits: ['custom-event'],
  setup(props, { emit }) {
    const triggerEvent = () => {
      emit('custom-event');
    }
  }
}




样式计算完整示例
场景描述

假设有以下 HTML 和 CSS 代码：

html
Copy Code
<!DOCTYPE html>
<html>
<head>
  <style>
    div { color: red; } 
    .text { color: blue; }
    #title { color: green; }
  </style>
</head>
<body>
  <div id="title" class="text" style="color: yellow;">Hello World</div>
</body>
</html>

浏览器样式计算过程
步骤 1：收集所有样式规则‌

浏览器会收集所有可能影响元素的样式来源，优先级从低到高依次为：

浏览器默认样式（如 <div> 默认 display: block）
开发者定义的样式（<style> 标签或外部 CSS）
内联样式（style 属性）

本例中涉及以下规则：

css
Copy Code
div { color: red; }            /* 标签选择器 */
.text { color: blue; }         /* 类选择器 */
#title { color: green; }       /* ID选择器 */
style="color: yellow;"         /* 内联样式 */

步骤 2：计算选择器优先级（Specificity）‌

优先级计算公式：[内联, ID, 类/伪类/属性, 标签]，数值越大优先级越高。

规则‌	‌优先级值‌
div { color: red; }	[0,0,0,1]
.text { color: blue; }	[0,0,1,0]
#title { color: green; }	[0,1,0,0]
style="color: yellow;"	[1,0,0,0]

结论‌：内联样式优先级最高，最终 color: yellow 胜出。

步骤 3：处理继承与默认值‌

某些属性（如 color、font-size）会继承父元素的值，但本例中 <div> 是根元素，无父级继承。

如果删除内联样式，优先级顺序为：#title > .text > div，最终颜色为 green。
如果删除所有样式，浏览器默认颜色为 black。
步骤 4：生成 Computed Style‌

最终应用到 <div> 的样式计算结果：

css
Copy Code
color: yellow;     /* 来自内联样式 */  
display: block;    /* 来自浏览器默认样式 */

关键机制总结

优先级（Specificity）‌：

内联样式 > ID选择器 > 类/伪类选择器 > 标签选择器‌
同类规则比较时，后定义的样式覆盖先定义的（源码顺序）

继承性‌：
color、font、line-height 等属性默认继承
width、margin、padding 等属性默认不继承
默认值‌：
未被任何规则覆盖的属性使用浏览器默认值（如 display: block）



html渲染过程：下面步骤：解析html，样式计算，布局，分块，绘制，分层，光栅化.
前端页面渲染核心流程详解

以下是浏览器渲染页面的核心步骤及其技术细节，按执行顺序梳理：

一、‌解析 HTML‌
DOM 树构建‌
渲染主线程将 HTML 字符串逐行解析为 ‌DOM 树‌（Document Object Model），每个 HTML 标签对应一个 DOM 节点。
预解析优化‌：预解析线程提前扫描 HTML 文档，优先下载外部 CSS 和 JS 文件，避免主线程阻塞。

阻塞与执行‌
解析过程中遇到 <script> 标签时，默认会暂停 HTML 解析以加载和执行 JS 代码（除非标记 async 或 defer）。
<link> 标签引入的 CSS 文件会被并行下载，但不会阻塞 HTML 解析（除非内联样式或未使用预加载）。
二、‌样式计算（Style Calculation）‌
CSSOM 构建‌
解析 CSS 文件（包括浏览器默认样式、内联样式、外部样式）生成 ‌CSSOM 树‌（CSS Object Model）。
样式属性通过层叠（优先级计算）和继承规则确定最终值。
Computed Style 生成‌
将 DOM 树与 CSSOM 树结合，为每个 DOM 节点计算最终样式（如颜色、字体大小等），生成带样式的 DOM 树。
三、‌布局（Layout）‌
布局树（Render Tree）构建‌
基于带样式的 DOM 树生成 ‌布局树‌，仅包含可见元素（如隐藏元素、<head> 等被排除）。
节点尺寸和位置通过盒模型（width、margin 等）精确计算。

布局计算规则‌
块级元素按垂直方向排列，行内元素按水平排列，遵循流式布局规则。
四、‌分层（Layering）‌
分层策略‌
将页面划分为多个独立层级（如滚动容器、动画元素、定位元素等），提升渲染效率。
分层决策依据：z-index、opacity、transform 等属性。
优化意义‌
仅更新受影响层级，避免全页面重绘（如滚动时仅更新特定层）。

五、‌绘制（Paint）‌
绘制指令生成‌
主线程为每个图层生成 ‌绘制指令集‌（如绘制矩形、文本等操作的详细描述）。
示例指令：绘制红色矩形（位置、尺寸、颜色等参数）。
提交至合成线程‌
主线程将绘制指令提交给 ‌合成线程‌，后续渲染流程由合成线程接管。

六、‌分块（Tiling）与光栅化（Rasterization）‌
分块处理‌
合成线程将每个图层划分为 ‌图块‌（Tile，通常为 256x256 或 512x512 像素），优先处理靠近视口的图块。
分块支持“懒加载”式渲染，提升长页面滚动性能。

光栅化执行‌
GPU 加速‌：光栅化线程（通常由 GPU 执行）将矢量绘制指令转换为 ‌像素数据‌，存储为位图。
复杂效果（如阴影、渐变）在此阶段完成像素级计算。
七、‌合成与呈现（Composite & Display）‌
合成操作‌
合成线程将光栅化后的图块按层级顺序组合成完整页面图像。
提交至显示系统‌
最终图像通过 ‌GPU 进程‌ 提交给操作系统或显示器驱动，完成屏幕刷新。
关键优化点
减少重排（Reflow）与重绘（Repaint）‌
布局和绘制阶段开销大，应避免频繁修改样式或 DOM 结构。
利用分层与合成‌
使用 transform 或 opacity 实现动画，可跳过布局和绘制阶段，直接由合成线程处理。
分块与光栅化并行‌
多线程协作（主线程、合成线程、光栅化线程）提升渲染效率。


CSS核心两大块：
css 属性值计算过程包括（层叠，继承）
视觉格式化模型（盒模型，包含块，流式布局，浮动布局，BFC）


BFC
1、概念
https://blog.csdn.net/Cui_7788/article/details/103135878?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-103135878-blog-121292449.235^v43^pc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=2
BFC：块级格式化上下文，是页面中的一块渲染区域，有一套自己的渲染规则，决定子元素如何定位，以及和其他元素的关系和相互作用
2、作用

作用：可以将BFC理解成一个箱子，不会影响箱子外部，解决传统布局带来的问题

传统布局问题：
相邻块元素的垂直外边距合并：两个盒子设置BFC
嵌套块元素的垂直外边距塌陷：父级盒子设置BFC，父元素position
浮动流造成父级元素高度坍塌：父级盒子设置BFC
浮动元素覆盖：非浮动元素设置BFC
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
                        
原文链接：https://blog.csdn.net/weixin_44706267/article/details/121292449


CSS 的核心两项
一、‌盒模型（Box Model）‌

盒模型定义了元素的‌尺寸计算规则‌，包含四个层级结构：content（内容区）、padding（内边距）、border（边框）、margin（外边距）。

块盒（Block）‌：通过 width 和 height 设置内容区尺寸，完整包含 padding 和 border，垂直方向 margin 会叠加。
行盒（Inline）‌：宽高由内容决定，无法直接设置 width 和 height，垂直方向的 padding 和 border 不占据布局空间（仅水平方向生效）。
二、‌显示模式（Display Mode）‌

通过 display 属性控制元素的‌布局行为‌，决定元素在文档流中的排列方式与交互规则：

块级显示（Block）‌：独占一行，可设置宽高，默认宽度为父容器 100%。
行内显示（Inline）‌：水平排列，宽高由内容撑开，无法设置垂直方向 margin 和 padding。
行内块（Inline-Block）‌：兼具块级可设宽高与行内水平排列的特性，如 <img>、<input> 等元素默认此模式。
核心作用总结
特性‌	‌盒模型‌	‌显示模式‌
布局控制‌	决定元素占据的实际空间（包含内容、间距、边框）	决定元素排列方式（独占行或水平排列）及尺寸控制能力
设计意义‌	统一元素尺寸计算规则，避免布局错位	通过 display 属性灵活切换元素的渲染逻辑，适配不同场景需求
典型应用
盒模型‌：精确控制元素间距（如导航栏按钮间距）或实现等高布局（通过 padding 和 margin 调整）。
显示模式‌：用 inline-block 实现水平菜单项，或通过 block 构建页面容器结构。

shallowRef是Vue3中的一个响应式API，用于创建浅层响应式对象。与ref不同，shallowRef仅对.value属性进行响应式跟踪，不会递归处理嵌套对象。这意味着修改嵌套属性时不会触发视图更新
性能敏感场景‌：优先用于深层嵌套对象、大数据集合以减少递归追踪开销‌14。
‌数据不可变或外部集成‌：适用于仅需监听整体引用变化的场景‌27。
‌精准更新控制‌：需手动管理更新逻辑时，通过替换 .value 触发响应‌

Vue 2：选项式 API（data、methods 分离）‌2。
Vue 3：组合式 API（setup 函数整合逻辑，支持逻辑复用


    Vue 2 无法检测对象属性新增/删除（需用 Vue.set/Vue.delete）和数组部分方法（如 splice 需覆盖）‌13。
    Vue 3 的 Proxy 已解决上述问题‌2。
生命周期调整‌
    Vue 3 移除 beforeCreate 和 created，统一由 setup 替代‌23。
    新增 onBeforeUnmount 和 onUnmounted 替代 beforeDestroy 和 destroyed‌23。

Vue 3 支持 ‌Tree Shaking‌（按需引入模块），打包体积更小‌

组件通信方式‌
    ‌父子‌：props + $emit‌14。
    ‌兄弟/跨级‌：事件总线（Event Bus）、provide/inject、Vuex/Pinia‌45。
    ‌Vue 3 新增‌：defineProps、defineEmits 编译器宏‌2。


行盒（Inline）与块盒（Block）的核心区别
一、‌功能目标与显示方式‌
特性‌	‌行盒（Inline）‌	‌块盒（Block）‌
排列方式‌	水平排列，与其他行盒共享同一行，宽度由内容决定	垂直排列，独占一行，宽度默认占满父容器
内容范围‌	仅容纳文本、行内元素或行块盒，不可嵌套块盒	可包含行盒、块盒及其他复杂内容
二、‌尺寸控制与盒模型‌

行盒‌

宽高‌：由内容决定，无法直接设置 width 和 height，调整内容尺寸（如字体大小）可间接改变布局。
盒模型‌：垂直方向的 padding 和 border 不占据布局空间（仅背景覆盖），水平方向有效。
示例‌：
css
Copy Code
span {  
  padding: 10px; /* 水平方向生效，垂直方向不改变布局高度 */  
  border: 1px solid red;  
}  


块盒‌

宽高‌：可自由设置 width 和 height，默认宽度占满父容器。
盒模型‌：包含完整的 content、padding、border、margin，垂直和水平方向均影响布局。
示例‌：
css
Copy Code
div {  
  width: 300px;  
  padding: 20px; /* 所有方向均占据空间 */  
  margin: 10px auto; /* 水平居中 */  
}  

三、‌典型应用场景‌

行盒适用场景‌

文本段落中的部分样式（如 <span> 高亮关键词）。
图标、按钮等需水平排列的小元素。

块盒适用场景‌

布局容器（如 <div> 包裹页面区块）。
导航栏、列表项等需独占一行的组件。
四、‌扩展类型：行块盒（Inline-Block）‌
特性‌：结合行盒与块盒特点，可水平排列且支持设置宽高。
应用‌：
css
Copy Code
.inline-block {  
  display: inline-block;  
  width: 100px; /* 生效 */  
  vertical-align: middle; /* 控制垂直对齐 */  
}  

五、‌注意事项‌
空白折叠‌：行盒之间连续的空白符（如换行、空格）会被折叠为单个空格。
替换元素‌：<img>、<video> 等默认生成行盒，但宽高可设置（类似行块盒）。
旧术语问题‌：避免使用“块级元素”“行内元素”等表述，改用“块盒”“行盒”以匹配 CSS 规范。
总结

行盒与块盒是 CSS 布局的基础单位：

行盒‌：轻量级水平排列，适合文本修饰与简单交互。
块盒‌：结构化垂直布局，支撑复杂页面框架。
核心差异‌：排列方向、尺寸控制能力、盒模型对布局的影响范围。

