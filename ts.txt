Lossless-JSON的主要作用是解析和字符串化JSON数据时，不会丢失数字信息，特别是处理大数字时能够保持精度。‌
作用

Lossless-JSON的主要作用是解决原生JSON.parse和JSON.stringify在处理大数字时可能出现的精度损失问题。它能够精确地解析和字符串化大数字，保证在处理JSON数据时不会丢失任何数字信息。Lossless-JSON通过将数值存储为字符串的轻量级类LosslessNumber，避免了信息丢失
yargs-parser‌是一个用于解析命令行参数的库，主要用于将命令行参数解析成一个对象，方便在Node.js应用程序中使用这些参数。

Wonka 的应用场景

Wonka 适用于多种场景，特别是在需要处理异步数据流或需要对数据进行复杂转换的场景中表现尤为出色：

    ‌前端开发‌：在现代前端框架中，如React或Vue，Wonka 可以用于处理复杂的用户交互事件流，如表单输入、按钮点击等。
    ‌后端开发‌：在Node.js环境中，Wonka 可以用于处理 HTTP 请求流、数据库查询结果流等。
    ‌数据处理‌：在数据科学或机器学习领域，Wonka 可以用于处理大规模数据集，进行数据清洗、转换和聚合‌1。
import { stream } from 'wonka';

// 创建一个简单的流，模拟用户点击事件
const clickStream = stream(() => {
  let count = 0;
  return {
    subscribe(observer) {
      const interval = setInterval(() => {
        observer.next({ type: 'click', count });
        count++;
      }, 1000);
      return () => clearInterval(interval);
    }
  };
});




vueuse/core 是 Vue 3 生态系统中的一个库，它提供了一系列实用的 Composition API 函数，旨在简化 Vue 开发中的常见任务。vueuse/core 库由 Antfu 创建，并被广泛认为是 Vue 3 中最受欢迎的实用函数库之一。
主要作用

    简化状态管理：通过提供诸如 useToggle, useLocalStorage, useMouse 等函数，简化了状态管理、事件处理和副作用管理等。

    提高代码可读性和复用性：通过提供一系列封装好的函数，开发者可以更容易地编写可读性和可维护性高的代码。
lodash
var _ = require('lodash');
循环 //lodash的times方法
    _.times(5,function(a){
        console.log(a);
    });
2、深层查找属性值
 var ownerArr = [{
        "owner": "Colin",
        "pets": [{"name": "dog1"}, {"name": "dog2"}]
    }, {
        "owner": "John",
        "pets": [{"name": "dog3"}, {"name": "dog4"}]
    }];


 var lodashMap = _.map(ownerArr, 'pets[0].name');
    console.log('------- lodashMap -------');
    console.log(lodashMap);
3、深克隆对象
 var objB = _.cloneDeep(objA);
5、扩展对象
  Object.prototype.extend = function(obj) {
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {    //判断被扩展的对象有没有某个属性，
                this[i] = obj[i];
            }
        }
    };

    var objA = {"name": "戈德斯文", "car": "宝马"};
    var objB = {"name": "柴硕", "loveEat": true};

    objA.extend(objB);
    console.log(objA); 

    console.log(_.assign(objA, objB));

7、判断对象中是否含有某元素
 var smartPerson = {
            'name': '戈德斯文',
            'gender': 'male'
        },
        smartTeam = ["戈德斯文", "杨海月", "柴硕", "师贝贝"];


    console.log(_.includes(smartPerson, '戈德斯文'));
    console.log(_.includes(smartTeam, '杨海月'));
    console.log(_.includes(smartTeam, '杨海月',2));

zod 验证 类型约束
import { z } from 'zod';

const FormSchema = z.object({
  name: z.string().min(3),
  email: z.string().email(),
  password: z.string().min(8),
});

const formData = { name: 'John Doe', email: 'john@example.com', password: 'password123' };
try {
  const validatedForm = FormSchema.parse(formData);
  console.log('表单验证通过:', validatedForm);
} catch (error) {
  console.error('表单验证失败:', error);
}

io-ts 是一个用于运行时类型系统，主要用于输入输出（IO）数据的解码和编码，io-ts 依赖于 fp-ts 库，如果版本不匹配，可能会导致编译错误或运行时错误。



接口（interface）与类型别名（type）的区别‌

    ‌接口‌：定义对象结构，支持继承（extends）和声明合并（同名接口自动合并）‌13。
    ‌类型别名‌：可为任意类型命名（联合、交叉、元组等），不支持合并‌34。

typescriptCopy Code
interface User { name: string; }
interface User { age: number; }  // 合并为 { name: string; age: number; }
type ID = string | number;        // 联合类型别名

联合类型与交叉类型‌

    ‌联合类型（|）‌：允许变量为多种类型之一，如string | number‌45。
    ‌交叉类型（&）‌：合并多个类型的属性，如A & B‌45。

typescriptCopy Code
type Admin = { role: string } & User;  // 合并Admin与User属性

any与unknown的区别‌

    ‌any‌：绕过类型检查，可能导致运行时错误‌58。
    ‌unknown‌：需通过类型断言或收窄后才可操作，更安全‌。

typescriptCopy Code
let data: unknown = fetchData();
if (typeof data === "string") data.toUpperCase();  // 类型收窄

模块（module）与命名空间（namespace）‌
    ‌模块‌：基于文件作用域，使用import/export管理依赖‌36。
    ‌命名空间‌：逻辑分组代码，避免全局污染（适用于旧代码迁移）‌36。

实用工具类型（Utility Types）‌

    ‌Partial<T>‌：所有属性变为可选。
    ‌Pick<T, K>‌：选取指定属性‌5。

typescriptCopy Code
type User = { id: number; name: string; };
type UserPreview = Pick<User, "name">;  // { name: string; }

如何实现一个DeepReadonly类型？‌
    递归遍历对象属性并添加readonly修饰符‌

Exclude<T, U>与Extract<T, U>的区别‌

    ‌Exclude‌：从T中移除U中的类型‌7。
    ‌Extract‌：保留T中与U匹配的类型‌7。
type T = Exclude<'a' | 'b' | 'c', 'a' | 'b'>;  // 'c'
type U = Extract<'a' | 1 | false, string>;      // 'a'

如何为第三方库扩展类型定义？‌
    使用声明合并（declare module）或编写.d.ts文件‌36。
typescriptCopy Code
// 扩展axios类型
declare module 'axios' {
  interface AxiosRequestConfig {
    retry?: number;
  }
}

如何避免this的类型丢失问题？‌

    显式声明函数中的this类型‌58。

typescriptCopy Code
interface User {
  name: string;
  greet(this: User): void;
}
const user: User = {
  name: 'Alice',
  greet() { console.log(this.name); }  // this类型明确为User
};


// 定义一个键为字符串、值为数字的对象类型
type Scores = Record<string, number>;
const examScores: Scores = { math: 90, english: 85 };
// 联合类型作为键
type Keys = "name" | "age";
type Person = Record<Keys, string | number>;
const user: Person = { name: "Alice", age: 25 };
适用场景‌：
    定义枚举值的映射关系。
    动态生成具有固定值类型的对象结构

// 从联合类型中排除特定类型
type AllowedKeys = "id" | "name" | "email";
type SensitiveKeys = Exclude<AllowedKeys, "email">; // "id" | "name"

// 排除基本类型
type Primitive = string | number | boolean;
type NonString = Exclude<Primitive, string>; // number | boolean
Exclude<T, U>‌
‌用途‌：从类型 T 中排除U 的类型。



interface User {
  id: number;
  name: string;
  password: string;
  email: string;
}

// 移除敏感字段（"password"）
type SafeUser = Omit<User, "password">;
// 等价于 { id: number; name: string; email: string }

// 移除多个字段
type PublicProfile = Omit<User, "password" | "email">;
// 等价于 { id: number; name: string }
‌适用场景‌：
    扩展接口时隐藏敏感字段。
    复用已有类型时剔除冗余属性。

Exclude vs Omit‌
    Exclude 操作的是 ‌联合类型‌，Omit 操作的是 ‌对象类型‌
type T1 = Exclude<"a" | "b" | "c", "a">;       // "b" | "c"
type T2 = Omit<{ a: 1; b: 2; c: 3 }, "a">;      // { b: 2; c: 3 }

